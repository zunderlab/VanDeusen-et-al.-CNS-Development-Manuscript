#Corey Williams, edited by Austin Keeler and Ashley Hirt, University of Virginia
#21 Feb, 2020, edited August 21st, 2020
#Run URD on CyTOF data
#
#To use this code, run each section (denoted by = signs) separately 
#following instructions at top of section
#
#This process and QC is outlined in 
#https://github.com/farrellja/URD/blob/master/Analyses/QuickStart/URD-QuickStart-AxialMesoderm.md
#
#Other parameter troubleshooting can be found on Github through some googling
#
#Most run parameters are left as written in tutorial, so not optimized in our hands. 
#Be ready to troubleshoot


print("Start URD_CyTOF.R")

rm(list = ls())
.libPaths(c(.libPaths(), "~/R/4.1.1"))

library(URD)
library(umap)
library(dplyr)

print("Libraries loaded")

## Input parameters ===============================================================================
#Change filenames as relevant, section should run without issue
INPUT.FOLDER <- getwd()
OUTPUT.FOLDER <- INPUT.FOLDER
CONCATTRANSFORMED.URD.FILENAME <- "/Concat_Transformed_Subsampled.csv" #.txt file for URD
URD.META.FILENAME <- "/metadata_URD.csv" #.txt file for URD, as generated by GetUrdMetadata.R
PANEL.FILENAME <- "/panel_URD.csv"
ROOT.STAGE.TAG <- NULL #Metadata tag for cells to be considered roots in pseudotime, leave null if clusters defined in metadata, ex input is "E14"
TIP.STAGE.TAG <- NULL #Metadata tag for cells to be considered tips in pseudotime, leave null if clusters defined in metadata, ex input is "P4"

print("Input parameters loaded")

#' Panel file input
#'
#' Reads panel file and produces format friendly to scripts in Zunder lab pipeline
#' @param input.folder directory containing metadata file
#' @param panel.filename panel filename, defaults to panel.csv as outputted by generation script
#' @importFrom utils read.csv
#' @export
read.panel <- function(input.folder,panel.filename = "/panel_URD.csv"){
  panel <- read.csv(paste0(input.folder,panel.filename))
  panel$Antigen <- gsub("-", "_", panel$Antigen)
  panel$Antigen <- gsub("\\.", "_", panel$Antigen)
  return(panel)
}

#' Concat_Transformed file input
#'
#' Reads Concat_Transformed file for use in Zunder lab pipeline
#' @param input.folder directory containing concat_transformed file
#' @param concat.transformed.filename concat_transformed filename, defaults to
#' Concat_Transformed.csv as outputted by generation script
#' @importFrom utils read.csv
#' @export
read.concat.transformed <- function(input.folder,
                                    concat.transformed.filename = "/Concat_Tranformed_Subsampled.csv"){
  concat.transformed <- read.csv(paste0(input.folder,concat.transformed.filename))
  colnames(concat.transformed) <- gsub("-", "_", colnames(concat.transformed))
  colnames(concat.transformed) <- gsub(".", "_", colnames(concat.transformed), fixed = TRUE)
  return(concat.transformed)
}

## Load needed files ==============================================================================
#Section should run without error, any issues will be in ZunderPipelineFunctions
concat.transformed <- read.concat.transformed(INPUT.FOLDER,CONCATTRANSFORMED.URD.FILENAME)
urd_meta <- read.metadata(INPUT.FOLDER,URD.META.FILENAME)
panel <- read.panel(INPUT.FOLDER,PANEL.FILENAME)

#pull clustering variables from panel
clustering.vars <- colnames(concat.transformed)
clustering.vars <- clustering.vars[clustering.vars != "File"] #Note: This line can be repeated or changed to exclude other markers from URD analysis
#clustering.vars <- get.clustering.annotate(panel) #Original line for URD of Pipeline1 outputs - not needed when convert outputs of Pipeline2 because expression_matrix_analyses.csv only contains markers used for clustering + "File" column

## Make output folder =============================================================================
#get current time
time.now <- Sys.time()
#generate folder name
output.dir <- paste0(OUTPUT.FOLDER,"/",substr(time.now,start=1,stop=10),"_",
                     substr(time.now,start=12,stop=13),".",substr(time.now,start=15,stop=16),".",
                     substr(time.now,start=18,stop=19),"_URD")
#make output folder
dir.create(output.dir)
#set output folder as working directory
setwd(output.dir)

## Create URD object ==============================================================================
#Section should run without issue

#Define function to make URD object from CyTOF data
#' Create a new URD object
#' 
#' Creates a new URD object. Provide asinh-transformed cytometry data in standard format 
#' with cells in rows and measurements in columns. Metadata should also have rows corresponding
#'  to cells Will transpose data & metadata and place same in both slot \code{count.data} and 
#'  slot \code{logupx.data}, the metadata in slot \code{meta}, and an initial grouping of the 
#'  data drawn from the cell names, up to the first dash (-) or underscore (_) in 
#'  slot \code{group.ids}. Removes filtering from original function
#' 
#' @importClassesFrom Matrix dgCMatrix
#' @importFrom methods new
#' 
#' @param count.data (Matrix or dgCMatrix) UMI expression data, 
#' with rows as genes and columns as cells
#' @param meta (data.frame) Metadata, with rows as cells (row names should match column names of
#'  \code{count.data})
#' @param gene.max.cut (Numeric) Maximum number of UMIs observed for a gene in a single cell
#'  to retain it
#' @param max.genes.in.ram (Numeric) Number of genes to normalize and log-transform at a time 
#' (to prevent running out of memory as matrices become non-sparse during the process)
#' 
#' @return An URD object
#' 
#' @export
createCyTOFURD <- function(count.data, meta=NULL, verbose=T) {
  
  count.data <- as.matrix(as.data.frame(t(count.data)))
  
  # Create an URD object
  if (verbose) message(paste0(Sys.time(), ": Creating URD object."))
  object <- methods::new("URD", count.data=as(count.data, "dgCMatrix"))
  shhhh <- gc()
  
  # Fill @logupx.data using pre-transformed data
  shhhh <- gc()
  object@logupx.data <- object@count.data
  
  # Set up the grouping IDs
  if (verbose) message(paste0(Sys.time(), ": Finishing setup of the URD object."))
  initial.group <- factor(unlist(lapply(colnames(object@logupx.data),
                                        function(x) strsplit(x,"_|-")[[1]][1] )))
  names(initial.group) <- colnames(object@logupx.data)
  object@group.ids <- data.frame(initial.group)
  names(object@group.ids) <- "init"
  
  # Set up the metadata
  object@meta <- as.data.frame(meta)
  rownames(object@meta) <- colnames(object@count.data)
  
  if (verbose) message(paste0(Sys.time(), ": All done."))
  return(object)
} 

URD_Object <- createCyTOFURD(concat.transformed,urd_meta)

print("URD object created")

## Get variable genes =============================================================================
#Run section, it will print text reiterating the clustering variables
#Currently, gene selection is done from panel file
URD_Object@var.genes <- clustering.vars


## Calculate PCA and tSNE (UMAP) ==================================================================
#Bottom of section will produce a plot colored by stage 
#Note: We are using UMAP, but putting in the tSNE slot of URD object, so axis labels will say tSNE

#calculate pca (needed later)
URD_Object <- calcPCA(URD_Object, mp.factor = 2)

#plot pca SD's
png("PCA_Stdev.png")
pcSDPlot(URD_Object)
dev.off()

#calculate umap
URD_Object@tsne.y <- as.data.frame(umap(t(as.matrix(URD_Object@logupx.data))
                                        [,URD_Object@var.genes])$layout)
colnames(URD_Object@tsne.y) <- c("tSNE1","tSNE2")

#plot umap to evaluate results, feel free to change to color by any label other than stage
png("UMAP_by_stage.png")
plotDim(URD_Object,"stage")
dev.off()

## Calculate Diffusion map ========================================================================
#Plot diffusion components at end of this section

#Calculate
URD_Object <- calcDM(URD_Object)

#plot
png("Diffusion_components.png")
plotDimArray(URD_Object, reduction.use = "dm", dims.to.plot = 1:8, 
             outer.title = "Diffusion Map: Stage",label="stage", plot.title="", legend=F)
dev.off()
png("Diffusion_with_transitions.png")
plotDim(URD_Object, "stage", transitions.plot = 10000, 
        plot.title="Developmental stage (with transitions)")
dev.off()

print("finished calculating DM")

## Calculate Pseudotime ===========================================================================
#This section will output two plots, a stability plot. Should reach a qualitative asymptote
#Also outputted UMAP colored by pseudotime and distribution of dev. stages by pseudotime

#Identify root cells, as specified in metadata or by entire stage
if (is.null(ROOT.STAGE.TAG)==TRUE) {
  root.cells <- whichCells(URD_Object,"roots",c(TRUE,TRUE)) #have to do the two TRUE to hack
} else {
  #Define root cells as all cells in specified timepoint
  root.cells <- whichCells(URD_Object,"stage",ROOT.STAGE.TAG)
}

#Calculate pseudotime
pseudotime.out <- floodPseudotime(URD_Object,root.cells, n=500, minimum.cells.flooded = 1, verbose=F)
test_frac_na <- apply(pseudotime.out, 1, function(x) sum(is.na(x)))/dim(pseudotime.out)[2]
print(which(test_frac_na > 0.4)) 
print(max(test_frac_na))  #What is maximum fraction of NAs 


#Move pseudotime info into URD object
URD_Object <- floodPseudotimeProcess(URD_Object,pseudotime.out)
print(which(is.na(URD_Object@pseudotime[,"pseudotime"]))) # What did not get assigned pseudotime


#plot
png("Pseudotime_stability.png")
pseudotimePlotStabilityOverall(URD_Object)
dev.off()
png("UMAP_by_pseudotime.png")
plotDim(URD_Object, "pseudotime")
dev.off()
png("Stage_distributions_by_pseudotime.png")
plotDists(URD_Object, "pseudotime", "stage", plot.title="Pseudotime by stage")
dev.off()

print("Finished calculating pseudotime")

save.image("URD_PseudotimeFlood.RData")

## Find tips ======================================================================================
#This section will cluster cells from the final timepoint to define endpoints of pseudotime
#The section will output a UMAP plot colored by Louvain clusters (the defined endpoints)

# Create a subsetted object of just those cells from the final stage
if (is.null(TIP.STAGE.TAG) == TRUE) {
  #pull out cells with tip clusters
  final.cells <- urdSubset(URD_Object,cells.keep=whichCells(URD_Object, "tips", c(1,Inf)))
  
  URD_Object@group.ids[rownames(final.cells@group.ids),"tip.clusters"] <- final.cells@meta$tips
} else {
  final.cells <- urdSubset(URD_Object,cells.keep=whichCells(URD_Object, "stage", TIP.STAGE.TAG))
  
  #Have the ability to use separate clustering markers at this point. Contact Corey if wanted
  
  #Get 2D layout for final stage
  final.cells@tsne.y <- as.data.frame(umap(t(as.matrix(final.cells@logupx.data))
                                           [,final.cells@var.genes])$layout)
  colnames(final.cells@tsne.y) <- c("tSNE1","tSNE2")
  
  #Do graph-based clustering
  # Calculate graph clustering of these cells
  print(dim(final.cells@logupx.data))
  clustering_k <- 15
  final.cells <- graphClustering(final.cells, num.nn = clustering_k, do.jaccard=T, method="Louvain")
  
  #plot
  png("Final_point_UMAP.png")
  plotDim(final.cells, paste0("Louvain-",clustering_k), plot.title = "Louvain graph clustering",
          point.size=3)
  dev.off()
  
  #Move tip cluster identities into main object
  URD_Object@group.ids[rownames(final.cells@group.ids),"tip.clusters"] <- 
    final.cells@group.ids[,paste0("Louvain-",clustering_k)]
}

print("Finished finding tips")

## Biased random walks ============================================================================
#Find developmental trajectories by calculating walks through the data
#Second function in this section will output a curve for the logistic function
#End will plot tips on UMAP and visitation of other cells to that tip

# Determine the parameters of the logistic used to bias the transition probabilities. The procedure
# is relatively robust to this parameter, but the cell numbers may need to be modified for larger
# or smaller data sets.
png("Logistic_Function.png")
URD_Object.ptlogistic <- pseudotimeDetermineLogistic(URD_Object, "pseudotime", 
                                                     optimal.cells.forward=20, 
                                                     max.cells.back=40, do.plot = T)
dev.off()

# Bias the transition matrix acording to pseudotime
URD_Object.biased.tm <- pseudotimeWeightTransitionMatrix(URD_Object,
                                                         "pseudotime",
                                                         logistic.params=
                                                           URD_Object.ptlogistic)

# Simulate the biased random walks from each tip
URD_Object.walks <- simulateRandomWalksFromTips(URD_Object, tip.group.id="tip.clusters", 
                                                root.cells=root.cells, 
                                                transition.matrix = URD_Object.biased.tm, 
                                                n.per.tip = 25000, root.visits = 1, 
                                                max.steps = 5000, verbose = F)

# Process the biased random walks into visitation frequencies
URD_Object <- processRandomWalksFromTips(URD_Object, URD_Object.walks, verbose = F)

#Plot cells in each tip cluster
png("UMAP_Tip_Cells.png")
plotDim(URD_Object, "tip.clusters", plot.title="Cells in each tip")
dev.off()

#Plot visitation frequency from each tip
sapply(unique(URD_Object@group.ids[rownames(final.cells@group.ids), "tip.clusters"]),
       function(x){
         png(paste0("Visitation_Freq_Tip_",as.character(x),".png"))
         plotDim(URD_Object, paste0("visitfreq.log.",x), 
                 plot.title=paste0("Visitation frequency from tip ",x," (log10)"),
                 transitions.plot=10000)
         dev.off()
       })

print("Finished with biased random walks")


## Save R workspace image =========================================================================
save.image("URD_Final.RData")
#reset working directory
setwd("..")

print("Finish URD_CyTOF.R")
